{"version":3,"file":"persistQueryClient.production.min.js","sources":["../src/core/hydration.ts","../src/persistQueryClient/persist.ts","../src/reactjs/QueryClientProvider.tsx","../src/reactjs/isRestoring.tsx","../src/persistQueryClient/PersistQueryClientProvider.tsx"],"sourcesContent":["import type { QueryClient } from './queryClient'\nimport type { Query, QueryState } from './query'\nimport type {\n  MutationKey,\n  MutationOptions,\n  QueryKey,\n  QueryOptions,\n} from './types'\nimport type { Mutation, MutationState } from './mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  dehydrateMutations?: boolean\n  dehydrateQueries?: boolean\n  shouldDehydrateMutation?: ShouldDehydrateMutationFunction\n  shouldDehydrateQuery?: ShouldDehydrateQueryFunction\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport interface DehydratedState {\n  mutations: DehydratedMutation[]\n  queries: DehydratedQuery[]\n}\n\nexport type ShouldDehydrateQueryFunction = (query: Query) => boolean\n\nexport type ShouldDehydrateMutationFunction = (mutation: Mutation) => boolean\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n  }\n}\n\nfunction defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nfunction defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options: DehydrateOptions = {}\n): DehydratedState {\n  const mutations: DehydratedMutation[] = []\n  const queries: DehydratedQuery[] = []\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation =\n      options.shouldDehydrateMutation || defaultShouldDehydrateMutation\n\n    client\n      .getMutationCache()\n      .getAll()\n      .forEach(mutation => {\n        if (shouldDehydrateMutation(mutation)) {\n          mutations.push(dehydrateMutation(mutation))\n        }\n      })\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery =\n      options.shouldDehydrateQuery || defaultShouldDehydrateQuery\n\n    client\n      .getQueryCache()\n      .getAll()\n      .forEach(query => {\n        if (shouldDehydrateQuery(query)) {\n          queries.push(dehydrateQuery(query))\n        }\n      })\n  }\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach(dehydratedMutation => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n      },\n      dehydratedMutation.state\n    )\n  })\n\n  queries.forEach(dehydratedQuery => {\n    const query = queryCache.get(dehydratedQuery.queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey: dehydratedQuery.queryKey,\n        queryHash: dehydratedQuery.queryHash,\n      },\n      dehydratedQuery.state\n    )\n  })\n}\n","import {\n  QueryClient,\n  dehydrate,\n  DehydratedState,\n  DehydrateOptions,\n  HydrateOptions,\n  hydrate,\n} from '../core'\nimport { Promisable } from 'type-fest'\n\nexport interface Persister {\n  persistClient(persistClient: PersistedClient): Promisable<void>\n  restoreClient(): Promisable<PersistedClient | undefined>\n  removeClient(): Promisable<void>\n}\n\nexport interface PersistedClient {\n  timestamp: number\n  buster: string\n  clientState: DehydratedState\n}\n\nexport interface PersistQueryClienRootOptions {\n  /** The QueryClient to persist */\n  queryClient: QueryClient\n  /** The Persister interface for storing and restoring the cache\n   * to/from a persisted location */\n  persister: Persister\n  /** A unique string that can be used to forcefully\n   * invalidate existing caches if they do not share the same buster string */\n  buster?: string\n}\n\nexport interface PersistedQueryClientRestoreOptions\n  extends PersistQueryClienRootOptions {\n  /** The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be discarded */\n  maxAge?: number\n  /** The options passed to the hydrate function */\n  hydrateOptions?: HydrateOptions\n}\n\nexport interface PersistedQueryClientSaveOptions\n  extends PersistQueryClienRootOptions {\n  /** The options passed to the dehydrate function */\n  dehydrateOptions?: DehydrateOptions\n}\n\nexport interface PersistQueryClientOptions\n  extends PersistedQueryClientRestoreOptions,\n    PersistedQueryClientSaveOptions,\n    PersistQueryClienRootOptions {}\n\n/**\n * Restores persisted data to the QueryCache\n *  - data obtained from persister.restoreClient\n *  - data is hydrated using hydrateOptions\n * If data is expired, busted, empty, or throws, it runs persister.removeClient\n */\nexport async function persistQueryClientRestore({\n  queryClient,\n  persister,\n  maxAge = 1000 * 60 * 60 * 24,\n  buster = '',\n  hydrateOptions,\n}: PersistedQueryClientRestoreOptions) {\n  if (typeof window !== 'undefined') {\n    try {\n      const persistedClient = await persister.restoreClient()\n\n      if (persistedClient) {\n        if (persistedClient.timestamp) {\n          const expired = Date.now() - persistedClient.timestamp > maxAge\n          const busted = persistedClient.buster !== buster\n          if (expired || busted) {\n            persister.removeClient()\n          } else {\n            hydrate(queryClient, persistedClient.clientState, hydrateOptions)\n          }\n        } else {\n          persister.removeClient()\n        }\n      }\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') {\n        queryClient.getLogger().error(err)\n        queryClient\n          .getLogger()\n          .warn(\n            'Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.'\n          )\n      }\n      persister.removeClient()\n    }\n  }\n}\n\n/**\n * Persists data from the QueryCache\n *  - data dehydrated using dehydrateOptions\n *  - data is persisted using persister.persistClient\n */\nexport async function persistQueryClientSave({\n  queryClient,\n  persister,\n  buster = '',\n  dehydrateOptions,\n}: PersistedQueryClientSaveOptions) {\n  if (typeof window !== 'undefined') {\n    const persistClient: PersistedClient = {\n      buster,\n      timestamp: Date.now(),\n      clientState: dehydrate(queryClient, dehydrateOptions),\n    }\n\n    await persister.persistClient(persistClient)\n  }\n}\n\n/**\n * Subscribe to QueryCache and MutationCache updates (for persisting)\n * @returns an unsubscribe function (to discontinue monitoring)\n */\nexport function persistQueryClientSubscribe(\n  props: PersistedQueryClientSaveOptions\n) {\n  const unsubscribeQueryCache = props.queryClient\n    .getQueryCache()\n    .subscribe(() => {\n      persistQueryClientSave(props)\n    })\n\n  const unusbscribeMutationCache = props.queryClient\n    .getMutationCache()\n    .subscribe(() => {\n      persistQueryClientSave(props)\n    })\n\n  return () => {\n    unsubscribeQueryCache()\n    unusbscribeMutationCache()\n  }\n}\n\n/**\n * Restores persisted data to QueryCache and persists further changes.\n */\nexport function persistQueryClient(\n  props: PersistQueryClientOptions\n): [() => void, Promise<void>] {\n  let hasUnsubscribed = false\n  let persistQueryClientUnsubscribe: (() => void) | undefined\n  const unsubscribe = () => {\n    hasUnsubscribed = true\n    persistQueryClientUnsubscribe?.()\n  }\n\n  let restorePromise = Promise.resolve()\n\n  if (typeof window !== 'undefined') {\n    // Attempt restore\n    restorePromise = persistQueryClientRestore(props).then(() => {\n      if (!hasUnsubscribed) {\n        // Subscribe to changes in the query cache to trigger the save\n        persistQueryClientUnsubscribe = persistQueryClientSubscribe(props)\n      }\n    })\n  }\n\n  return [unsubscribe, restorePromise]\n}\n","import React from 'react'\n\nimport { QueryClient } from '../core'\nimport { ContextOptions } from '../reactjs/types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext))\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","import React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","import React from 'react'\n\nimport { persistQueryClient, PersistQueryClientOptions } from './persist'\nimport { QueryClientProvider, QueryClientProviderProps } from '../reactjs'\nimport { IsRestoringProvider } from '../reactjs/isRestoring'\n\nexport type PersistQueryClientProviderProps = QueryClientProviderProps & {\n  persistOptions: Omit<PersistQueryClientOptions, 'queryClient'>\n  onSuccess?: () => void\n}\n\nexport const PersistQueryClientProvider = ({\n  client,\n  children,\n  persistOptions,\n  onSuccess,\n  ...props\n}: PersistQueryClientProviderProps): JSX.Element => {\n  const [isRestoring, setIsRestoring] = React.useState(true)\n  const refs = React.useRef({ persistOptions, onSuccess })\n\n  React.useEffect(() => {\n    refs.current = { persistOptions, onSuccess }\n  })\n\n  React.useEffect(() => {\n    let isStale = false\n    setIsRestoring(true)\n    const [unsubscribe, promise] = persistQueryClient({\n      ...refs.current.persistOptions,\n      queryClient: client,\n    })\n\n    promise.then(() => {\n      if (!isStale) {\n        refs.current.onSuccess?.()\n        setIsRestoring(false)\n      }\n    })\n\n    return () => {\n      isStale = true\n      unsubscribe()\n    }\n  }, [client])\n\n  return (\n    <QueryClientProvider client={client} {...props}>\n      <IsRestoringProvider value={isRestoring}>{children}</IsRestoringProvider>\n    </QueryClientProvider>\n  )\n}\n"],"names":["defaultShouldDehydrateMutation","mutation","state","isPaused","defaultShouldDehydrateQuery","query","status","dehydrate","client","options","mutations","queries","dehydrateMutations","shouldDehydrateMutation","getMutationCache","getAll","forEach","push","mutationKey","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","getQueryCache","queryKey","queryHash","dehydrateQuery","async","persistQueryClientRestore","queryClient","persister","maxAge","buster","hydrateOptions","window","persistedClient","restoreClient","timestamp","expired","Date","now","busted","removeClient","dehydratedState","mutationCache","queryCache","dehydratedMutation","_options$defaultOptio","build","defaultOptions","dehydratedQuery","_options$defaultOptio2","get","dataUpdatedAt","setState","hydrate","clientState","err","persistQueryClientSave","dehydrateOptions","persistClient","persistQueryClientSubscribe","props","unsubscribeQueryCache","subscribe","unusbscribeMutationCache","persistQueryClient","hasUnsubscribed","persistQueryClientUnsubscribe","restorePromise","Promise","resolve","then","defaultContext","React","createContext","undefined","QueryClientSharingContext","QueryClientProvider","children","context","contextSharing","useEffect","mount","unmount","Context","ReactQueryClientContext","getQueryClientContext","createElement","Provider","value","IsRestoringProvider","persistOptions","onSuccess","isRestoring","setIsRestoring","useState","refs","useRef","current","isStale","unsubscribe","promise","_extends"],"mappings":"0XAmEA,SAASA,EAA+BC,GACtC,OAAOA,EAASC,MAAMC,SAGxB,SAASC,EAA4BC,GACnC,MAA8B,YAAvBA,EAAMH,MAAMI,OAGd,SAASC,EACdC,EACAC,EAA4B,IAEtBC,MAAAA,EAAkC,GAClCC,EAA6B,GAEnC,IAAmC,IAA/BF,EAAQG,mBAA8B,CACxC,MAAMC,EACJJ,EAAQI,yBAA2Bb,EAErCQ,EACGM,mBACAC,SACAC,SAAQf,IACHY,EAAwBZ,IAC1BS,EAAUO,KA3CpB,SAA2BhB,GAClB,MAAA,CACLiB,YAAajB,EAASQ,QAAQS,YAC9BhB,MAAOD,EAASC,OAwCKiB,CAAkBlB,OAKzC,IAAiC,IAA7BQ,EAAQW,iBAA4B,CACtC,MAAMC,EACJZ,EAAQY,sBAAwBjB,EAElCI,EACGc,gBACAP,SACAC,SAAQX,IACHgB,EAAqBhB,IACvBM,EAAQM,KA9ClB,SAAwBZ,GACf,MAAA,CACLH,MAAOG,EAAMH,MACbqB,SAAUlB,EAAMkB,SAChBC,UAAWnB,EAAMmB,WA0CEC,CAAepB,OAK7B,MAAA,CAAEK,UAAAA,EAAWC,QAAAA,GClDfe,eAAeC,GAA0BC,YAC9CA,EAD8CC,UAE9CA,EAF8CC,OAG9CA,EAAS,MAHqCC,OAI9CA,EAAS,GAJqCC,eAK9CA,IAEA,GAAsB,oBAAXC,OACL,IACF,MAAMC,QAAwBL,EAAUM,gBAExC,GAAID,EACEA,GAAAA,EAAgBE,UAAW,CACvBC,MAAAA,EAAUC,KAAKC,MAAQL,EAAgBE,UAAYN,EACnDU,EAASN,EAAgBH,SAAWA,EACtCM,GAAWG,EACbX,EAAUY,eDqCf,SACLjC,EACAkC,EACAjC,GAEI,GAA2B,iBAApBiC,GAAoD,OAApBA,EACzC,OAGF,MAAMC,EAAgBnC,EAAOM,mBACvB8B,EAAapC,EAAOc,gBAGpBZ,EAAagC,EAAoChC,WAAa,GAE9DC,EAAW+B,EAAoC/B,SAAW,GAEhED,EAAUM,SAAQ6B,IAAsB,IAAAC,EACtCH,EAAcI,MACZvC,EACA,IACE,MAAGC,GAAA,OAAHqC,EAAGrC,EAASuC,qBAAZ,EAAGF,EAAyBpC,UAC5BQ,YAAa2B,EAAmB3B,aAElC2B,EAAmB3C,UAIvBS,EAAQK,SAAQiC,IAAmB,IAAAC,EAC3B7C,MAAAA,EAAQuC,EAAWO,IAAIF,EAAgBzB,WAGzCnB,EACEA,EAAMH,MAAMkD,cAAgBH,EAAgB/C,MAAMkD,eACpD/C,EAAMgD,SAASJ,EAAgB/C,OAMnC0C,EAAWG,MACTvC,EACA,IACE,MAAGC,GAAA,OAAHyC,EAAGzC,EAASuC,qBAAZ,EAAGE,EAAyBvC,QAC5BY,SAAU0B,EAAgB1B,SAC1BC,UAAWyB,EAAgBzB,WAE7ByB,EAAgB/C,UClFVoD,CAAQ1B,EAAaM,EAAgBqB,YAAavB,QAGpDH,EAAUY,eAGd,MAAOe,GASP3B,EAAUY,gBAUTf,eAAe+B,GAAuB7B,YAC3CA,EAD2CC,UAE3CA,EAF2CE,OAG3CA,EAAS,GAHkC2B,iBAI3CA,IAEA,GAAsB,oBAAXzB,OAAwB,CACjC,MAAM0B,EAAiC,CACrC5B,OAAAA,EACAK,UAAWE,KAAKC,MAChBgB,YAAahD,EAAUqB,EAAa8B,UAGhC7B,EAAU8B,cAAcA,IAQ3B,SAASC,EACdC,GAEMC,MAAAA,EAAwBD,EAAMjC,YACjCN,gBACAyC,WAAU,KACTN,EAAuBI,MAGrBG,EAA2BH,EAAMjC,YACpCd,mBACAiD,WAAU,KACTN,EAAuBI,MAG3B,MAAO,KACLC,IACAE,KAOG,SAASC,EACdJ,GAEIK,IACAC,EADAD,GAAkB,EAOtB,IAAIE,EAAiBC,QAAQC,UAY7B,MAVsB,oBAAXrC,SAETmC,EAAiBzC,EAA0BkC,GAAOU,MAAK,KAChDL,IAEHC,EAAgCP,EAA4BC,QAK3D,CAjBa,KAClBK,GAAkB,EAClB,MAAAC,GAAAA,KAemBC,mNC/JhB,MAAMI,EAAiBC,EAAK,QAACC,mBAClCC,GAEIC,EAA4BH,EAAK,QAACC,eAAuB,GAuDxD,MAAMG,EAAsB,EACjCrE,OAAAA,EACAsE,SAAAA,EACAC,QAAAA,EACAC,eAAAA,GAAiB,MAEjBP,EAAK,QAACQ,WAAU,KACdzE,EAAO0E,QACA,KACL1E,EAAO2E,aAER,CAAC3E,IAEJ,MAAM4E,EA3DR,SACEL,EACAC,GAEA,OAAID,IAGAC,GAAoC,oBAAX/C,QACtBA,OAAOoD,0BACVpD,OAAOoD,wBAA0Bb,GAG5BvC,OAAOoD,yBAGTb,GA4CSc,CAAsBP,EAASC,GAG7C,OAAAP,UAAAc,cAACX,EAA0BY,SAA3B,CAAoCC,OAAQV,GAAWC,GACrDP,UAAAc,cAACH,EAAQI,SAAT,CAAkBC,MAAOjF,GAASsE,KCjF3BY,EAHcjB,EAAK,QAACC,eAAc,GAGOc,sCCMZ,EACxChF,OAAAA,EACAsE,SAAAA,EACAa,eAAAA,EACAC,UAAAA,KACG/B,MAEG,MAACgC,EAAaC,GAAkBrB,EAAAA,QAAMsB,UAAS,GAC/CC,EAAOvB,EAAK,QAACwB,OAAO,CAAEN,eAAAA,EAAgBC,UAAAA,IA2B5C,OAzBAnB,EAAK,QAACQ,WAAU,KACde,EAAKE,QAAU,CAAEP,eAAAA,EAAgBC,UAAAA,MAGnCnB,EAAK,QAACQ,WAAU,KACVkB,IAAAA,GAAU,EACdL,GAAe,GACf,MAAOM,EAAaC,GAAWpC,EAAmB,IAC7C+B,EAAKE,QAAQP,eAChB/D,YAAapB,IAUf,OAPA6F,EAAQ9B,MAAK,KACN4B,UACHH,EAAKE,QAAQN,WAAbI,EAAKE,QAAQN,YACbE,GAAe,OAIZ,KACLK,GAAU,EACVC,OAED,CAAC5F,IAGFiE,wBAACI,EAADyB,EAAA,CAAqB9F,OAAQA,GAAYqD,GACvCY,UAAAc,cAACG,EAAD,CAAqBD,MAAOI,GAAcf"}