import { makeSubject as t, share as r, filter as e, map as n, merge as a, mergeMap as u, empty as o, fromValue as i, takeUntil as h, fromPromise as f, toPromise as c, take as p, onStart as d } from "wonka";

import { makeOperation as v, createRequest as A } from "@urql/core";

function _extends() {
  return (_extends = Object.assign || function(t) {
    for (var r = 1; r < arguments.length; r++) {
      var e = arguments[r];
      for (var n in e) {
        if (Object.prototype.hasOwnProperty.call(e, n)) {
          t[n] = e[n];
        }
      }
    }
    return t;
  }).apply(this, arguments);
}

function addAuthAttemptToOperation(t, r) {
  return v(t.kind, t, _extends({}, t.context, {
    authAttempt: r
  }));
}

function authExchange(v) {
  var m = v.addAuthToOperation;
  var s = v.getAuth;
  var l = v.didAuthError;
  var k = v.willAuthError;
  return function(v) {
    var x = v.client;
    var y = v.forward;
    var O = new Map;
    var S = t();
    var w = S.source;
    var g = S.next;
    var E = null;
    return function(t) {
      function mutate(t, r, n) {
        var a = x.createRequestOperation("mutation", A(t, r), n);
        return c(p(1)(e((function(t) {
          return t.operation.key === a.key;
        }))(d((function() {
          return g(a);
        }))(j))));
      }
      function updateAuthState(t) {
        E = t;
        v = void 0;
        O.forEach(g);
        O.clear();
      }
      var v = Promise.resolve().then((function() {
        return s({
          authState: E,
          mutate: mutate
        });
      })).then(updateAuthState);
      function refreshAuth(t) {
        t = addAuthAttemptToOperation(t, !0);
        O.set(t.key, t);
        if (!v) {
          v = s({
            authState: E,
            mutate: mutate
          }).then(updateAuthState).catch((function() {
            return updateAuthState(null);
          }));
        }
      }
      var S = r(t);
      var T = e((function(t) {
        return "teardown" === t.kind;
      }))(S);
      var _ = e((function(t) {
        return "teardown" !== t.kind;
      }))(S);
      var b = n((function(t) {
        return m({
          operation: t,
          authState: E
        });
      }))(a([ w, u((function(t) {
        if (O.has(t.key)) {
          return o;
        }
        if (!v && k && k({
          operation: t,
          authState: E
        })) {
          refreshAuth(t);
          return o;
        } else if (!v) {
          return i(addAuthAttemptToOperation(t, !1));
        }
        var r = e((function(r) {
          return "teardown" === r.kind && r.key === t.key;
        }))(S);
        return h(r)(n((function() {
          return addAuthAttemptToOperation(t, !1);
        }))(f(v)));
      }))(_) ]));
      var j = r(y(a([ b, T ])));
      return e((function(t) {
        var r = t.error;
        var e = t.operation;
        if (r && l && l({
          error: r,
          authState: E
        })) {
          if (!e.context.authAttempt) {
            refreshAuth(e);
            return !1;
          }
        }
        return !0;
      }))(j);
    };
  };
}

export { authExchange };
//# sourceMappingURL=urql-exchange-auth.mjs.map
