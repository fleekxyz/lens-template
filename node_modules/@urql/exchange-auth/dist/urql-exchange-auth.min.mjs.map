{"version":3,"file":"urql-exchange-auth.min.mjs","sources":["../src/authExchange.ts"],"sourcesContent":["import {\n  pipe,\n  map,\n  mergeMap,\n  fromPromise,\n  fromValue,\n  filter,\n  onStart,\n  empty,\n  take,\n  makeSubject,\n  toPromise,\n  merge,\n  share,\n  takeUntil,\n} from 'wonka';\n\nimport {\n  Operation,\n  OperationContext,\n  OperationResult,\n  CombinedError,\n  Exchange,\n  createRequest,\n  makeOperation,\n  TypedDocumentNode,\n} from '@urql/core';\n\nimport { DocumentNode } from 'graphql';\n\nexport interface AuthConfig<T> {\n  /** addAuthToOperation() must be provided to add the custom `authState` to an Operation's context, so that it may be picked up by the `fetchExchange`. */\n  addAuthToOperation(params: {\n    authState: T | null;\n    operation: Operation;\n  }): Operation;\n\n  /** didAuthError() may be provided to tweak the detection of an authentication error that this exchange should handle. */\n  didAuthError?(params: { error: CombinedError; authState: T | null }): boolean;\n\n  /** willAuthError() may be provided to detect a potential operation that'll receive authentication error so that getAuth() can be run proactively. */\n  willAuthError?(params: {\n    authState: T | null;\n    operation: Operation;\n  }): boolean;\n\n  /** getAuth() handles how the application refreshes or reauthenticates given a stale `authState` and should return a new `authState` or `null`. */\n  getAuth(params: {\n    authState: T | null;\n    /** The mutate() method may be used to send one-off mutations to the GraphQL API for the purpose of authentication. */\n    mutate<Data = any, Variables extends object = {}>(\n      query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n      variables?: Variables,\n      context?: Partial<OperationContext>\n    ): Promise<OperationResult<Data>>;\n  }): Promise<T | null>;\n}\n\nconst addAuthAttemptToOperation = (\n  operation: Operation,\n  hasAttempted: boolean\n) =>\n  makeOperation(operation.kind, operation, {\n    ...operation.context,\n    authAttempt: hasAttempted,\n  });\n\nexport function authExchange<T>({\n  addAuthToOperation,\n  getAuth,\n  didAuthError,\n  willAuthError,\n}: AuthConfig<T>): Exchange {\n  return ({ client, forward }) => {\n    const retryQueue: Map<number, Operation> = new Map();\n    const {\n      source: retrySource$,\n      next: retryOperation,\n    } = makeSubject<Operation>();\n\n    let authState: T | null = null;\n\n    return operations$ => {\n      function mutate<Data = any, Variables extends object = {}>(\n        query: DocumentNode | string,\n        variables?: Variables,\n        context?: Partial<OperationContext>\n      ): Promise<OperationResult<Data>> {\n        const operation = client.createRequestOperation(\n          'mutation',\n          createRequest(query, variables),\n          context\n        );\n\n        return pipe(\n          result$,\n          onStart(() => retryOperation(operation)),\n          filter(result => result.operation.key === operation.key),\n          take(1),\n          toPromise\n        );\n      }\n\n      const updateAuthState = (newAuthState: T | null) => {\n        authState = newAuthState;\n        authPromise = undefined;\n        retryQueue.forEach(retryOperation);\n        retryQueue.clear();\n      };\n\n      let authPromise: Promise<any> | void = Promise.resolve()\n        .then(() => getAuth({ authState, mutate }))\n        .then(updateAuthState);\n\n      const refreshAuth = (operation: Operation): void => {\n        // add to retry queue to try again later\n        operation = addAuthAttemptToOperation(operation, true);\n        retryQueue.set(operation.key, operation);\n\n        // check that another operation isn't already doing refresh\n        if (!authPromise) {\n          authPromise = getAuth({ authState, mutate })\n            .then(updateAuthState)\n            .catch(() => updateAuthState(null));\n        }\n      };\n\n      const sharedOps$ = pipe(operations$, share);\n\n      const teardownOps$ = pipe(\n        sharedOps$,\n        filter((operation: Operation) => {\n          return operation.kind === 'teardown';\n        })\n      );\n\n      const pendingOps$ = pipe(\n        sharedOps$,\n        filter((operation: Operation) => {\n          return operation.kind !== 'teardown';\n        })\n      );\n\n      const opsWithAuth$ = pipe(\n        merge([\n          retrySource$,\n          pipe(\n            pendingOps$,\n            mergeMap(operation => {\n              if (retryQueue.has(operation.key)) {\n                return empty;\n              }\n\n              if (\n                !authPromise &&\n                willAuthError &&\n                willAuthError({ operation, authState })\n              ) {\n                refreshAuth(operation);\n                return empty;\n              } else if (!authPromise) {\n                return fromValue(addAuthAttemptToOperation(operation, false));\n              }\n\n              const teardown$ = pipe(\n                sharedOps$,\n                filter(op => {\n                  return op.kind === 'teardown' && op.key === operation.key;\n                })\n              );\n\n              return pipe(\n                fromPromise(authPromise),\n                map(() => addAuthAttemptToOperation(operation, false)),\n                takeUntil(teardown$)\n              );\n            })\n          ),\n        ]),\n        map(operation => addAuthToOperation({ operation, authState }))\n      );\n\n      const result$ = pipe(merge([opsWithAuth$, teardownOps$]), forward, share);\n\n      return pipe(\n        result$,\n        filter(({ error, operation }) => {\n          if (error && didAuthError && didAuthError({ error, authState })) {\n            if (!operation.context.authAttempt) {\n              refreshAuth(operation);\n              return false;\n            }\n          }\n\n          return true;\n        })\n      );\n    };\n  };\n}\n"],"names":["addAuthAttemptToOperation","operation","hasAttempted","makeOperation","kind","_extends","context","authAttempt","authExchange","retryQueue","Map","makeSubject","authState","operations$","mutate","query","variables","client","createRequestOperation","createRequest","toPromise","take","filter","result","key","onStart","retryOperation","result$","updateAuthState","newAuthState","authPromise","undefined","forEach","clear","Promise","resolve","then","getAuth","refreshAuth","set","catch","sharedOps$","share","teardownOps$","pendingOps$","opsWithAuth$","map","addAuthToOperation","merge","retrySource$","mergeMap","has","empty","willAuthError","fromValue","teardown$","op","takeUntil","fromPromise","forward","error","didAuthError"],"mappings":"mdA0DMA,EACJC,EACAC,UAEAC,EAAcF,EAAUG,KAAMH,EAAWI,KACpCJ,EAAUK,SACbC,YAAaL,cAGDM,6HAONC,EAAqC,IAAIC,MAI3CC,wBAEAC,EAAsB,qBAEnBC,YACIC,EACPC,EACAC,EACAV,OAEML,EAAYgB,EAAOC,uBACvB,WACAC,EAAcJ,EAAOC,GACrBV,UAQAc,EADAC,EAAK,EAALA,CADAC,YAAOC,UAAUA,EAAOtB,UAAUuB,MAAQvB,EAAUuB,MAApDF,CADAG,qBAAcC,EAAezB,KAA7BwB,CADAE,eAQEC,EAAmBC,GACvBjB,EAAYiB,EACZC,OAAcC,EACdtB,EAAWuB,QAAQN,GACnBjB,EAAWwB,YAGTH,EAAmCI,QAAQC,UAC5CC,wBAAWC,EAAQ,WAAEzB,SAAWE,OAChCsB,KAAKR,YAEFU,EAAerC,GAEnBA,EAAYD,EAA0BC,GAAW,GACjDQ,EAAW8B,IAAItC,EAAUuB,IAAKvB,GAGzB6B,IACHA,EAAcO,EAAQ,WAAEzB,SAAWE,IAChCsB,KAAKR,GACLY,yBAAYZ,EAAgB,cAI7Ba,EAA+BC,EAAb7B,GAElB8B,EAEJrB,YAAQrB,SACoB,aAAnBA,EAAUG,OADnBkB,CADAmB,GAMIG,EAEJtB,YAAQrB,SACoB,aAAnBA,EAAUG,OADnBkB,CADAmB,GAMII,EAoCJC,YAAI7C,UAAa8C,EAAmB,WAAE9C,YAAWW,MAAjDkC,CAnCAE,EAAM,CACJC,EAGEC,YAASjD,MACHQ,EAAW0C,IAAIlD,EAAUuB,YACpB4B,MAINtB,GACDuB,GACAA,EAAc,WAAEpD,YAAWW,WAE3B0B,EAAYrC,GACLmD,EACF,IAAKtB,SACHwB,EAAUtD,EAA0BC,GAAW,QAGlDsD,EAEJjC,YAAOkC,SACc,aAAZA,EAAGpD,MAAuBoD,EAAGhC,MAAQvB,EAAUuB,MADxDF,CADAmB,UASAgB,EAAUF,EAAVE,CADAX,qBAAU9C,EAA0BC,GAAW,KAA/C6C,CADAY,EAAY5B,OAxBhBoB,CADAN,MAmCAjB,EAA6De,EAATiB,EAArCX,EAAM,CAACH,EAAcF,aAIxCrB,mDACMsC,GAASC,GAAgBA,EAAa,OAAED,YAAOhD,MAC5CX,EAAUK,QAAQC,cACrB+B,EAAYrC,GACL,MAJbqB,CADAK"}