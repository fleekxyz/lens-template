{"version":3,"file":"urql-exchange-auth.js","sources":["../src/authExchange.ts"],"sourcesContent":["import {\n  pipe,\n  map,\n  mergeMap,\n  fromPromise,\n  fromValue,\n  filter,\n  onStart,\n  empty,\n  take,\n  makeSubject,\n  toPromise,\n  merge,\n  share,\n  takeUntil,\n} from 'wonka';\n\nimport {\n  Operation,\n  OperationContext,\n  OperationResult,\n  CombinedError,\n  Exchange,\n  createRequest,\n  makeOperation,\n  TypedDocumentNode,\n} from '@urql/core';\n\nimport { DocumentNode } from 'graphql';\n\nexport interface AuthConfig<T> {\n  /** addAuthToOperation() must be provided to add the custom `authState` to an Operation's context, so that it may be picked up by the `fetchExchange`. */\n  addAuthToOperation(params: {\n    authState: T | null;\n    operation: Operation;\n  }): Operation;\n\n  /** didAuthError() may be provided to tweak the detection of an authentication error that this exchange should handle. */\n  didAuthError?(params: { error: CombinedError; authState: T | null }): boolean;\n\n  /** willAuthError() may be provided to detect a potential operation that'll receive authentication error so that getAuth() can be run proactively. */\n  willAuthError?(params: {\n    authState: T | null;\n    operation: Operation;\n  }): boolean;\n\n  /** getAuth() handles how the application refreshes or reauthenticates given a stale `authState` and should return a new `authState` or `null`. */\n  getAuth(params: {\n    authState: T | null;\n    /** The mutate() method may be used to send one-off mutations to the GraphQL API for the purpose of authentication. */\n    mutate<Data = any, Variables extends object = {}>(\n      query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n      variables?: Variables,\n      context?: Partial<OperationContext>\n    ): Promise<OperationResult<Data>>;\n  }): Promise<T | null>;\n}\n\nconst addAuthAttemptToOperation = (\n  operation: Operation,\n  hasAttempted: boolean\n) =>\n  makeOperation(operation.kind, operation, {\n    ...operation.context,\n    authAttempt: hasAttempted,\n  });\n\nexport function authExchange<T>({\n  addAuthToOperation,\n  getAuth,\n  didAuthError,\n  willAuthError,\n}: AuthConfig<T>): Exchange {\n  return ({ client, forward }) => {\n    const retryQueue: Map<number, Operation> = new Map();\n    const {\n      source: retrySource$,\n      next: retryOperation,\n    } = makeSubject<Operation>();\n\n    let authState: T | null = null;\n\n    return operations$ => {\n      function mutate<Data = any, Variables extends object = {}>(\n        query: DocumentNode | string,\n        variables?: Variables,\n        context?: Partial<OperationContext>\n      ): Promise<OperationResult<Data>> {\n        const operation = client.createRequestOperation(\n          'mutation',\n          createRequest(query, variables),\n          context\n        );\n\n        return pipe(\n          result$,\n          onStart(() => retryOperation(operation)),\n          filter(result => result.operation.key === operation.key),\n          take(1),\n          toPromise\n        );\n      }\n\n      const updateAuthState = (newAuthState: T | null) => {\n        authState = newAuthState;\n        authPromise = undefined;\n        retryQueue.forEach(retryOperation);\n        retryQueue.clear();\n      };\n\n      let authPromise: Promise<any> | void = Promise.resolve()\n        .then(() => getAuth({ authState, mutate }))\n        .then(updateAuthState);\n\n      const refreshAuth = (operation: Operation): void => {\n        // add to retry queue to try again later\n        operation = addAuthAttemptToOperation(operation, true);\n        retryQueue.set(operation.key, operation);\n\n        // check that another operation isn't already doing refresh\n        if (!authPromise) {\n          authPromise = getAuth({ authState, mutate })\n            .then(updateAuthState)\n            .catch(() => updateAuthState(null));\n        }\n      };\n\n      const sharedOps$ = pipe(operations$, share);\n\n      const teardownOps$ = pipe(\n        sharedOps$,\n        filter((operation: Operation) => {\n          return operation.kind === 'teardown';\n        })\n      );\n\n      const pendingOps$ = pipe(\n        sharedOps$,\n        filter((operation: Operation) => {\n          return operation.kind !== 'teardown';\n        })\n      );\n\n      const opsWithAuth$ = pipe(\n        merge([\n          retrySource$,\n          pipe(\n            pendingOps$,\n            mergeMap(operation => {\n              if (retryQueue.has(operation.key)) {\n                return empty;\n              }\n\n              if (\n                !authPromise &&\n                willAuthError &&\n                willAuthError({ operation, authState })\n              ) {\n                refreshAuth(operation);\n                return empty;\n              } else if (!authPromise) {\n                return fromValue(addAuthAttemptToOperation(operation, false));\n              }\n\n              const teardown$ = pipe(\n                sharedOps$,\n                filter(op => {\n                  return op.kind === 'teardown' && op.key === operation.key;\n                })\n              );\n\n              return pipe(\n                fromPromise(authPromise),\n                map(() => addAuthAttemptToOperation(operation, false)),\n                takeUntil(teardown$)\n              );\n            })\n          ),\n        ]),\n        map(operation => addAuthToOperation({ operation, authState }))\n      );\n\n      const result$ = pipe(merge([opsWithAuth$, teardownOps$]), forward, share);\n\n      return pipe(\n        result$,\n        filter(({ error, operation }) => {\n          if (error && didAuthError && didAuthError({ error, authState })) {\n            if (!operation.context.authAttempt) {\n              refreshAuth(operation);\n              return false;\n            }\n          }\n\n          return true;\n        })\n      );\n    };\n  };\n}\n"],"names":["makeOperation","authAttempt","retryQueue","ref","authState","operations$","take","operation","filter","retryOperation","authPromise","clear","mutate","catch","teardownOps$","kind","wonka","retrySource$"],"mappings":";;;;;;;;;;;;;;;;;;SA8DEA;;IAAaC;;;;;;;;;;;QAYLC,IAAUC;;;;QAMZC;;oBAGFC;;kBAeIC;6BADiBA,KAAyBC,KAASC;UAHrD,SAESD;cAAOE;UAFhB;;;;QAWAC;QACAR;QACAA,EAAWS;;;;;;;;;;QAUXT;;;gBAIwB;;YAARU;mCAEiBC;YAF/B;;;;UAQEC;cAGeC;QAHH;SAGGA;cAODC;QAHH;SAGGA;;;qBAwC+BZ;;;oBA9B7Ba,GAAcD;;;;;qBAOCZ;UAH7BA;;;;;;;gBAcWY;UAHI;WAGJA;8BAM0BA,OAAA;UAFrC;WAEqCA;SAxBTA;;;;;;;UAsChCZ;;yBAEeH;wBACXM;;;;QANR;"}