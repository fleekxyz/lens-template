{"version":3,"file":"urql-exchange-auth.mjs","sources":["../src/authExchange.ts"],"sourcesContent":["import {\n  pipe,\n  map,\n  mergeMap,\n  fromPromise,\n  fromValue,\n  filter,\n  onStart,\n  empty,\n  take,\n  makeSubject,\n  toPromise,\n  merge,\n  share,\n  takeUntil,\n} from 'wonka';\n\nimport {\n  Operation,\n  OperationContext,\n  OperationResult,\n  CombinedError,\n  Exchange,\n  createRequest,\n  makeOperation,\n  TypedDocumentNode,\n} from '@urql/core';\n\nimport { DocumentNode } from 'graphql';\n\nexport interface AuthConfig<T> {\n  /** addAuthToOperation() must be provided to add the custom `authState` to an Operation's context, so that it may be picked up by the `fetchExchange`. */\n  addAuthToOperation(params: {\n    authState: T | null;\n    operation: Operation;\n  }): Operation;\n\n  /** didAuthError() may be provided to tweak the detection of an authentication error that this exchange should handle. */\n  didAuthError?(params: { error: CombinedError; authState: T | null }): boolean;\n\n  /** willAuthError() may be provided to detect a potential operation that'll receive authentication error so that getAuth() can be run proactively. */\n  willAuthError?(params: {\n    authState: T | null;\n    operation: Operation;\n  }): boolean;\n\n  /** getAuth() handles how the application refreshes or reauthenticates given a stale `authState` and should return a new `authState` or `null`. */\n  getAuth(params: {\n    authState: T | null;\n    /** The mutate() method may be used to send one-off mutations to the GraphQL API for the purpose of authentication. */\n    mutate<Data = any, Variables extends object = {}>(\n      query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n      variables?: Variables,\n      context?: Partial<OperationContext>\n    ): Promise<OperationResult<Data>>;\n  }): Promise<T | null>;\n}\n\nconst addAuthAttemptToOperation = (\n  operation: Operation,\n  hasAttempted: boolean\n) =>\n  makeOperation(operation.kind, operation, {\n    ...operation.context,\n    authAttempt: hasAttempted,\n  });\n\nexport function authExchange<T>({\n  addAuthToOperation,\n  getAuth,\n  didAuthError,\n  willAuthError,\n}: AuthConfig<T>): Exchange {\n  return ({ client, forward }) => {\n    const retryQueue: Map<number, Operation> = new Map();\n    const {\n      source: retrySource$,\n      next: retryOperation,\n    } = makeSubject<Operation>();\n\n    let authState: T | null = null;\n\n    return operations$ => {\n      function mutate<Data = any, Variables extends object = {}>(\n        query: DocumentNode | string,\n        variables?: Variables,\n        context?: Partial<OperationContext>\n      ): Promise<OperationResult<Data>> {\n        const operation = client.createRequestOperation(\n          'mutation',\n          createRequest(query, variables),\n          context\n        );\n\n        return pipe(\n          result$,\n          onStart(() => retryOperation(operation)),\n          filter(result => result.operation.key === operation.key),\n          take(1),\n          toPromise\n        );\n      }\n\n      const updateAuthState = (newAuthState: T | null) => {\n        authState = newAuthState;\n        authPromise = undefined;\n        retryQueue.forEach(retryOperation);\n        retryQueue.clear();\n      };\n\n      let authPromise: Promise<any> | void = Promise.resolve()\n        .then(() => getAuth({ authState, mutate }))\n        .then(updateAuthState);\n\n      const refreshAuth = (operation: Operation): void => {\n        // add to retry queue to try again later\n        operation = addAuthAttemptToOperation(operation, true);\n        retryQueue.set(operation.key, operation);\n\n        // check that another operation isn't already doing refresh\n        if (!authPromise) {\n          authPromise = getAuth({ authState, mutate })\n            .then(updateAuthState)\n            .catch(() => updateAuthState(null));\n        }\n      };\n\n      const sharedOps$ = pipe(operations$, share);\n\n      const teardownOps$ = pipe(\n        sharedOps$,\n        filter((operation: Operation) => {\n          return operation.kind === 'teardown';\n        })\n      );\n\n      const pendingOps$ = pipe(\n        sharedOps$,\n        filter((operation: Operation) => {\n          return operation.kind !== 'teardown';\n        })\n      );\n\n      const opsWithAuth$ = pipe(\n        merge([\n          retrySource$,\n          pipe(\n            pendingOps$,\n            mergeMap(operation => {\n              if (retryQueue.has(operation.key)) {\n                return empty;\n              }\n\n              if (\n                !authPromise &&\n                willAuthError &&\n                willAuthError({ operation, authState })\n              ) {\n                refreshAuth(operation);\n                return empty;\n              } else if (!authPromise) {\n                return fromValue(addAuthAttemptToOperation(operation, false));\n              }\n\n              const teardown$ = pipe(\n                sharedOps$,\n                filter(op => {\n                  return op.kind === 'teardown' && op.key === operation.key;\n                })\n              );\n\n              return pipe(\n                fromPromise(authPromise),\n                map(() => addAuthAttemptToOperation(operation, false)),\n                takeUntil(teardown$)\n              );\n            })\n          ),\n        ]),\n        map(operation => addAuthToOperation({ operation, authState }))\n      );\n\n      const result$ = pipe(merge([opsWithAuth$, teardownOps$]), forward, share);\n\n      return pipe(\n        result$,\n        filter(({ error, operation }) => {\n          if (error && didAuthError && didAuthError({ error, authState })) {\n            if (!operation.context.authAttempt) {\n              refreshAuth(operation);\n              return false;\n            }\n          }\n\n          return true;\n        })\n      );\n    };\n  };\n}\n"],"names":["addAuthAttemptToOperation","operation","hasAttempted","makeOperation","kind","_extends","context","authAttempt","authExchange","retryQueue","Map","makeSubject","authState","operations$","mutate","query","variables","client","createRequestOperation","createRequest","toPromise","take","filter","result","key","onStart","retryOperation","result$","updateAuthState","newAuthState","authPromise","undefined","forEach","clear","Promise","resolve","then","getAuth","refreshAuth","set","catch","sharedOps$","share","teardownOps$","pendingOps$","opsWithAuth$","map","addAuthToOperation","merge","retrySource$","mergeMap","has","empty","willAuthError","fromValue","teardown$","op","takeUntil","fromPromise","forward","error","didAuthError"],"mappings":";;;;;;;;;;;;;;;;;;SA0DMA,0BACJC,GACAC;SAEAC,EAAcF,EAAUG,MAAMH,GAAWI,aACpCJ,EAAUK;IACbC,aAAaL;;;;SAGDM;;;;;;;;QAONC,IAAqC,IAAIC;YAI3CC;;;QAEAC,IAAsB;oBAEnBC;eACIC,OACPC,GACAC,GACAV;YAEML,IAAYgB,EAAOC,uBACvB,YACAC,EAAcJ,GAAOC,IACrBV;eAQAc,EADAC,EAAK,EAALA,CADAC,YAAOC;iBAAUA,EAAOtB,UAAUuB,QAAQvB,EAAUuB;WAApDF,CADAG;iBAAcC,EAAezB;WAA7BwB,CADAE;;eAQEC,gBAAmBC;QACvBjB,IAAYiB;QACZC,SAAcC;QACdtB,EAAWuB,QAAQN;QACnBjB,EAAWwB;;UAGTH,IAAmCI,QAAQC,UAC5CC;eAAWC,EAAQ;qBAAEzB;kBAAWE;;UAChCsB,KAAKR;eAEFU,YAAerC;QAEnBA,IAAYD,0BAA0BC,IAAW;QACjDQ,EAAW8B,IAAItC,EAAUuB,KAAKvB;aAGzB6B;UACHA,IAAcO,EAAQ;uBAAEzB;oBAAWE;aAChCsB,KAAKR,iBACLY;mBAAYZ,gBAAgB;;;;UAI7Ba,IAA+BC,EAAb7B;UAElB8B,IAEJrB,YAAQrB;eACoB,eAAnBA,EAAUG;SADnBkB,CADAmB;UAMIG,IAEJtB,YAAQrB;eACoB,eAAnBA,EAAUG;SADnBkB,CADAmB;UAMII,IAoCJC,YAAI7C;eAAa8C,EAAmB;qBAAE9C;qBAAWW;;SAAjDkC,CAnCAE,EAAM,EACJC,GAGEC,YAASjD;YACHQ,EAAW0C,IAAIlD,EAAUuB;iBACpB4B;;aAINtB,KACDuB,KACAA,EAAc;qBAAEpD;qBAAWW;YAC3B;UACA0B,YAAYrC;iBACLmD;eACF,KAAKtB;iBACHwB,EAAUtD,0BAA0BC,IAAW;;YAGlDsD,IAEJjC,YAAOkC;iBACc,eAAZA,EAAGpD,QAAuBoD,EAAGhC,QAAQvB,EAAUuB;WADxDF,CADAmB;eASAgB,EAAUF,EAAVE,CADAX;iBAAU9C,0BAA0BC,IAAW;WAA/C6C,CADAY,EAAY5B;SAxBhBoB,CADAN;UAmCAjB,IAA6De,EAATiB,EAArCX,EAAM,EAACH,GAAcF;aAIxCrB;;;YACMsC,KAASC,KAAgBA,EAAa;iBAAED;qBAAOhD;;eAC5CX,EAAUK,QAAQC,aAAa;YAClC+B,YAAYrC;oBACL;;;gBAIJ;SARTqB,CADAK;;;;;"}