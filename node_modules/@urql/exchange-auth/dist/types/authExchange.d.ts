import { Operation, OperationContext, OperationResult, CombinedError, Exchange, TypedDocumentNode } from '@urql/core';
import { DocumentNode } from 'graphql';
export interface AuthConfig<T> {
    /** addAuthToOperation() must be provided to add the custom `authState` to an Operation's context, so that it may be picked up by the `fetchExchange`. */
    addAuthToOperation(params: {
        authState: T | null;
        operation: Operation;
    }): Operation;
    /** didAuthError() may be provided to tweak the detection of an authentication error that this exchange should handle. */
    didAuthError?(params: {
        error: CombinedError;
        authState: T | null;
    }): boolean;
    /** willAuthError() may be provided to detect a potential operation that'll receive authentication error so that getAuth() can be run proactively. */
    willAuthError?(params: {
        authState: T | null;
        operation: Operation;
    }): boolean;
    /** getAuth() handles how the application refreshes or reauthenticates given a stale `authState` and should return a new `authState` or `null`. */
    getAuth(params: {
        authState: T | null;
        /** The mutate() method may be used to send one-off mutations to the GraphQL API for the purpose of authentication. */
        mutate<Data = any, Variables extends object = {}>(query: DocumentNode | TypedDocumentNode<Data, Variables> | string, variables?: Variables, context?: Partial<OperationContext>): Promise<OperationResult<Data>>;
    }): Promise<T | null>;
}
export declare function authExchange<T>({ addAuthToOperation, getAuth, didAuthError, willAuthError, }: AuthConfig<T>): Exchange;
